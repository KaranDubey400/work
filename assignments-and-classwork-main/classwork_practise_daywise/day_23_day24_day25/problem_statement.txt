Linked List: 
Requirements
1) Processes
 
Build two separate processes:
 
Process A (Producer/Mutator)
 
Process B (Reader/Analytics)
 
Both processes must attach to the same POSIX shared memory region using:
 
shm_open, ftruncate, mmap


 
2) Shared Memory Data Structures
 
In shared memory, 


store:
 
A fixed-size node pool: MAX_NODES = 4096

 
A shared singly linked list of events (implemented using indices, not pointers)

 
A free-list to manage unused nodes

 
A list header containing: head_idx, tail_idx, count, version, shutdown

___________________________________________________________-
 
Each event node must contain:
 
event_id, sensor_id, timestamp, value, severity ,  next_idx

___________________________________________________--
 
3) Threads

Process A threads
 
Create Writer threads (2 threads):
 
Generate new events
 
Append them to the shared list

If list size exceeds MAX_EVENTS = 2000, 
evict oldest nodes from head

_____________________________________________
 
Create Updater thread (1 thread):
 
Randomly choose existing nodes
 
Update fields like severity and/or value

______________________________________________

Create Cleaner thread (1 thread):
 
Periodically remove events older than T seconds
 
Return removed nodes to the free-list
+++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
Process B threads

 
Create Snapshot Reader threads (2 threads):
 
Periodically traverse the shared list
 
Compute summary stats:
 
total count
 
average value per sensor
 
max severity

++++++++++++++++++++++++++++++++++++++++++++++++==
 
Create query thread (1 thread):
 
Support queries (hardcode or stdin simulation):
 
GET sensor_id
 
GET severity >= X
 
DUMP last N events
+++++++++++++++++++++++++++++++++++++++++++++++++++++
 
Create Watchdog thread (1 thread):

 
If version does not change for X seconds, print “possible deadlock/stall”.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
 
4) Synchronization (Must be process-shared)
 
Use synchronization primitives stored in shared memory:
 
One process-shared RW lock for the list (pthread_rwlock_t)
 
One process-shared mutex for the free-list allocator (pthread_mutex_t)

_________________________________________________________
 
Lock rules:
 
readers take read lock
 
Writers/updaters/cleaners take write lock

 
Free-list operations must use allocator mutex

 
Use a fixed lock order to avoid deadlocks:
 
list_rwlock → alloc_mutex
 
Writers must increment version on
 
append
 
delete/evict
 
update

__________________________________________________________________________
 
5) Memory Management
 
No malloc/free for nodes after init.
 
Nodes must be allocated only from the shared pool via free-list.
 
On deletion, node must be returned to free-list safely.

__________________________________________________________________________
 
6) Runtime + Output
 
Program must run continuously for at least 2 minutes without:
 
crashes
 
deadlocks
 
memory corruption
 
Print periodic logs:
 
Process A: appended count, evicted count, updated count
 
Process B: snapshot stats, query results, watchdog warnings
______________________________________________________________________________
 
7) Shutdown
 
shutdown flag in shared memory stops all threads cleanly.
 
Both processes must munmap shared memory.
 
One process (or a separate cleanup mode) must shm_unlink at the end.

_______________________________________________________________________________-


to run - gcc gcc shared_event_ll.c -o app -pthread

./app init .. to initializa shared memory 

./app A  start process A

./app B start process B